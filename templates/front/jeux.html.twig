{% extends 'front/base.html.twig' %}

{% block title %}Mini-Jeux IA - MentorAI
{% endblock %}

{% block stylesheets %}
	<style>:root
	{
		--color-deep-navy: #102c59;
		--color-steel-blue: #9dbbce;
		--color-accent-red: #d52e28;
		--primary-gradient: linear-gradient(135deg, var(--color-deep-navy) 0%, #1a3c78 100%);
		--accent-gradient: linear-gradient(135deg, var(--color-accent-red) 0%, #a0231e 100%);
		--glass-bg: rgba(255, 255, 255, 0.05);
		--glass-border: rgba(255, 255, 255, 0.1);
	}

	body {
		background-color: #324b74ff;
		color: white;
	}

	.game-hero {
		padding: 60px 0 40px;
		text-align: center;
		background: radial-gradient(circle at top right, rgba(213, 46, 40, 0.1), transparent), radial-gradient(circle at bottom left, rgba(16, 44, 89, 0.4), transparent);
	}

	.nav-pills .nav-link {
		color: var(--color-steel-blue);
		border: 1px solid var(--glass-border);
		background: var(--glass-bg);
		margin: 0 10px;
		border-radius: 50px;
		padding: 10px 30px;
		font-weight: 700;
		transition: all 0.3s;
	}

	.nav-pills .nav-link.active {
		background: var(--accent-gradient);
		border-color: transparent;
		color: white;
		box-shadow: 0 10px 20px rgba(213, 46, 40, 0.3);
	}

	/* Shared Styles */
	.stat-badge {
		background: var(--glass-bg);
		border: 1px solid var(--glass-border);
		padding: 10px 25px;
		border-radius: 50px;
		font-weight: 700;
		backdrop-filter: blur(10px);
	}

	.btn-restart {
		background: var(--accent-gradient);
		border: none;
		color: white;
		padding: 12px 35px;
		border-radius: 50px;
		font-weight: 800;
		text-transform: uppercase;
		letter-spacing: 1px;
		transition: all 0.3s;
		box-shadow: 0 5px 20px rgba(213, 46, 40, 0.4);
	}

	.btn-restart:hover {
		transform: scale(1.05);
		box-shadow: 0 8px 25px rgba(213, 46, 40, 0.6);
	}

	/* Memory Game Styles */
	.memory-grid {
		display: grid;
		grid-template-columns: repeat(4, 1fr);
		gap: 20px;
		max-width: 800px;
		margin: 0 auto 50px;
		perspective: 1000px;
	}

	.memory-card {
		height: 150px;
		position: relative;
		transform-style: preserve-3d;
		transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
		cursor: pointer;
	}

	.memory-card.flipped {
		transform: rotateY(180deg);
	}
	.memory-card.matched {
		transform: rotateY(180deg) scale(0.92);
		filter: drop-shadow(0 0 10px rgba(40, 167, 69, 0.3));
	}
	.memory-card.matched .card-back {
		background: rgba(40, 167, 69, 0.1) !important;
		border: 2px solid #28a745 !important;
	}
	.memory-card.matched .card-back i,
	.memory-card.matched .card-back span {
		color: #24921aff !important;
	}

	.card-face {
		position: absolute;
		width: 100%;
		height: 100%;
		backface-visibility: hidden;
		display: flex;
		align-items: center;
		justify-content: center;
		border-radius: 15px;
		border: 2px solid var(--glass-border);
	}

	.card-front {
		background: var(--primary-gradient);
		background-image: url("https://www.transparenttextures.com/patterns/carbon-fibre.png");
	}
	.card-front::after {
		content: '?';
		font-size: 3rem;
		font-weight: 800;
		color: rgba(255, 255, 255, 0.1);
	}
	.card-back {
		background: var(--glass-bg);
		transform: rotateY(180deg);
		flex-direction: column;
		gap: 10px;
	}
	.card-back i {
		font-size: 4rem;
		color: var(--color-accent-red);
	}
	.card-back span {
		font-weight: 700;
		color: var(--color-steel-blue);
	}

	/* Tic-Tac-Toe Styles */
	.ttt-grid {
		display: grid;
		grid-template-columns: repeat(3, 1fr);
		gap: 15px;
		max-width: 400px;
		margin: 0 auto 50px;
	}

	.ttt-cell {
		aspect-ratio: 1;
		background: var(--glass-bg);
		border: 2px solid var(--glass-border);
		border-radius: 15px;
		display: flex;
		align-items: center;
		justify-content: center;
		font-size: 2.5rem;
		cursor: pointer;
		transition: all 0.3s;
	}

	.ttt-cell:hover:not(.taken) {
		background: rgba(157, 187, 206, 0.1);
		border-color: var(--color-accent-red);
	}

	.ttt-cell.taken {
		cursor: default;
	}
	.ttt-cell.x {
		color: var(--color-accent-red);
		text-shadow: 0 0 15px rgba(213, 46, 40, 0.5);
	}
	.ttt-cell.o {
		color: var(--color-steel-blue);
		text-shadow: 0 0 15px rgba(157, 187, 206, 0.5);
	}

	.skill-icon {
		font-size: 1.2rem;
		margin-bottom: 5px;
		opacity: 0.6;
	}

	/* Fullstack Badge */
	#badge-notification {
		position: fixed;
		top: 20px;
		right: 20px;
		background: var(--accent-gradient);
		padding: 20px 30px;
		border-radius: 20px;
		box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5);
		display: none;
		z-index: 2000;
		animation: slideIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
	}

	@keyframes slideIn {
		from {
			transform: translateX(120%);
		}
		to {
			transform: translateX(0);
		}
	}

	#info-panel {
		position: fixed;
		bottom: 20px;
		left: 50%;
		transform: translateX(-50%);
		width: 90%;
		max-width: 600px;
		background: rgba(16, 44, 89, 0.95);
		border: 2px solid var(--color-accent-red);
		border-radius: 20px;
		padding: 20px;
		backdrop-filter: blur(20px);
		display: none;
		z-index: 100;
		animation: slideUp 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
	}
	/* Snake Game Styles */
	.snake-container {
		position: relative;
		width: 100%;
		max-width: 500px;
		margin: 0 auto;
		background: #000;
		border: 4px solid var(--glass-border);
		border-radius: 10px;
		overflow: hidden;
	}

	#snake-canvas {
		display: block;
		width: 100%;
		aspect-ratio: 1;
		image-rendering: pixelated;
	}

	.snake-overlay {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		background: rgba(16, 44, 89, 0.8);
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		z-index: 10;
		backdrop-filter: blur(5px);
	}

	.snake-score {
		position: absolute;
		top: 15px;
		right: 15px;
		font-weight: 800;
		font-family: 'Courier New', Courier, monospace;
		color: #0f0;
		font-size: 1.5rem;
		z-index: 5;
	}

	.food-icon {
		position: absolute;
		pointer-events: none;
		z-index: 5;
		font-size: 20px;
		transition: transform 0.2s;
	}

	/* Pong Game Styles */
	.pong-container {
		position: relative;
		width: 100%;
		max-width: 700px;
		margin: 0 auto;
		background: #050d1a;
		border: 4px solid var(--glass-border);
		border-radius: 15px;
		overflow: hidden;
		cursor: none; /* Hide cursor inside game */
	}

	#pong-canvas {
		display: block;
		width: 100%;
		aspect-ratio: 2 / 1;
	}

	.pong-overlay {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		background: rgba(16, 44, 89, 0.85);
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		z-index: 20;
		backdrop-filter: blur(8px);
	}

	.pong-score-board {
		display: flex;
		justify-content: space-between;
		width: 100%;
		padding: 15px 40px;
		position: absolute;
		top: 0;
		left: 0;
		font-family: 'Outfit', sans-serif;
		font-weight: 800;
		font-size: 1.2rem;
		z-index: 10;
		pointer-events: none;
	}

	.pong-label {
		font-size: 0.7rem;
		text-transform: uppercase;
		letter-spacing: 1px;
		opacity: 0.6;
		display: block;
	}

	.pong-hint {
		color: var(--color-steel-blue);
		font-size: 0.85rem;
		margin-top: 15px;
	}
	/* Tetris Game Styles */
	.tetris-container {
		display: flex;
		justify-content: center;
		gap: 30px;
		max-width: 600px;
		margin: 0 auto;
	}

	#tetris-canvas {
		border: 4px solid var(--glass-border);
		background: #000;
		border-radius: 10px;
		box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
	}

	.tetris-info {
		display: flex;
		flex-direction: column;
		gap: 20px;
		text-align: left;
	}

	.tetris-stat {
		background: var(--glass-bg);
		border: 1px solid var(--glass-border);
		padding: 15px 25px;
		border-radius: 15px;
		min-width: 150px;
	}

	.tetris-stat h6 {
		color: var(--color-steel-blue);
		font-size: 0.75rem;
		text-transform: uppercase;
		margin-bottom: 5px;
	}

	.tetris-stat div {
		font-size: 1.5rem;
		font-weight: 800;
	}

	.tetris-next {
		width: 100px;
		height: 100px;
		background: var(--glass-bg);
		border: 1px solid var(--glass-border);
		border-radius: 15px;
		display: flex;
		align-items: center;
		justify-content: center;
	}
</style>{% endblock %}{% block body %}
<section class="game-hero">
	<div class="container">
		<h1 class="display-4 fw-bold mb-4">MentorAI
			<span class="text-danger">Playground</span>
		</h1>

		<ul class="nav nav-pills justify-content-center mb-5" id="gameTabs" role="tablist">
			<li class="nav-item">
				<button class="nav-link active" id="memory-tab" data-bs-toggle="pill" data-bs-target="#memory" type="button">Memory Match</button>
			</li>
			<li class="nav-item">
				<button class="nav-link" id="ttt-tab" data-bs-toggle="pill" data-bs-target="#ttt" type="button">Tic-Tac-Toe</button>
			</li>
			<li class="nav-item">
				<button class="nav-link" id="snake-tab" data-bs-toggle="pill" data-bs-target="#snake" type="button">Snake AI</button>
			</li>
			<li class="nav-item">
				<button class="nav-link" id="pong-tab" data-bs-toggle="pill" data-bs-target="#pong" type="button">Recruit Pong</button>
			</li>
			<li class="nav-item">
				<button class="nav-link" id="tetris-tab" data-bs-toggle="pill" data-bs-target="#tetris" type="button">Clean Code Tetris</button>
			</li>
		</ul>

		<div
			class="tab-content" id="gameTabContent">
			<!-- Memory Game -->
			<div class="tab-pane fade show active" id="memory">
				<div class="game-stats justify-content-center mb-4 d-flex gap-3">
					<div class="stat-badge">Moves:
						<span id="move-count">0</span>
					</div>
					<div class="stat-badge">Matches:
						<span id="match-count">0</span>/8</div>
					<div class="stat-badge">Time:
						<span id="timer">00:00</span>
					</div>
				</div>

				<div class="d-flex justify-content-center mb-3">
					<button id="btn-webcam" class="btn btn-sm btn-outline-light rounded-pill px-3" onclick="toggleWebcam()">
						<i class="bi bi-camera-video me-2"></i>
						Activer Contrôle Main (IA)
					</button>
					<div id="hand-loading" class="ms-3 text-warning" style="display:none;">Chargement du modèle IA...</div>
				</div>

				<!-- Webcam Overlay -->
				<div id="webcam-container" style="position: fixed; bottom: 20px; right: 20px; width: 200px; height: 150px; border-radius: 15px; overflow: hidden; border: 2px solid var(--color-accent-red); display: none; z-index: 1000; background: #000;">
					<video id="input_video" style="width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1);"></video>
					<canvas id="output_canvas" width="200" height="150" style="position: absolute; top: 0; left: 0; transform: scaleX(-1);"></canvas>
				</div>

				<!-- Virtual Cursor -->
				<div id="virtual-cursor" style="position: fixed; top: 0; left: 0; width: 20px; height: 20px; background: rgba(213, 46, 40, 0.7); border: 2px solid #fff; border-radius: 50%; pointer-events: none; z-index: 9999; display: none; transition: background 0.1s; transform: translate(-50%, -50%); box-shadow: 0 0 10px rgba(213, 46, 40, 0.8);"></div>

				<div class="memory-grid" id="game-grid"></div>
				<button class="btn-restart" onclick="resetMemory()">Nouveau Jeu</button>
			</div>

			<!-- Tic-Tac-Toe -->
			<div class="tab-pane fade" id="ttt">
				<div class="game-stats justify-content-center mb-4 d-flex gap-3">
					<div class="stat-badge">Mode:
						<span id="ttt-mode">Solo vs IA</span>
					</div>
					<div class="stat-badge">Tour:
						<span id="ttt-turn">HTML (X)</span>
					</div>
				</div>
				<div class="ttt-grid" id="ttt-grid">
					{% for i in 0..8 %}
						<div class="ttt-cell" data-index="{{ i }}"></div>
					{% endfor %}
				</div>
				<div class="d-flex justify-content-center gap-3">
					<button class="btn-restart" onclick="resetTTT()">Rejouer</button>
					<button class="btn-restart" style="background: var(--glass-bg); border: 1px solid var(--glass-border);" onclick="toggleTTTMode()">Changer Mode</button>
				</div>
			</div>

			<!-- Snake Game -->
			<div class="tab-pane fade" id="snake">
				<div class="game-stats justify-content-center mb-4 d-flex gap-3">
					<div class="stat-badge">Persévérance:
						<span id="snake-pers-level">Débutant</span>
					</div>
					<div class="stat-badge">Score:
						<span id="snake-current-score">0</span>
					</div>
				</div>
				<div class="snake-container mb-4">
					<div id="snake-score" class="snake-score">0</div>
					<canvas id="snake-canvas" width="400" height="400"></canvas>
					<div id="snake-start-screen" class="snake-overlay">
						<i class="bi bi-controller fs-1 mb-3"></i>
						<h3 class="fw-bold mb-3">Snake : Codez votre chemin</h3>
						<p class="text-center px-4 small mb-4">Mangez les technos pour monter en niveau.<br>Attention aux murs et à votre propre code !</p>
						<button class="btn-restart" onclick="startSnake()">Lancer le Script</button>
					</div>
				</div>
				<div class="d-flex justify-content-center">
					<p class="text-muted small">
						<i class="bi bi-keyboard me-2"></i>Utilisez les flèches du clavier pour diriger le serpent</p>
				</div>
			</div>

			<!-- Pong Game -->
			<div class="tab-pane fade" id="pong">
				<div class="game-stats justify-content-center mb-4 d-flex gap-3">
					<div class="stat-badge">État:
						<span id="pong-status">En attente</span>
					</div>
					<div class="stat-badge">Vitesse CV:
						<span id="pong-speed">1x</span>
					</div>
				</div>
				<div class="pong-container mb-4" id="pong-box">
					<div class="pong-score-board">
						<div class="text-start">
							<span class="pong-label">Candidat (Vous)</span>
							<span id="player-score">0</span>
						</div>
						<div class="text-end">
							<span class="pong-label">IA Recruteur</span>
							<span id="ai-score">0</span>
						</div>
					</div>
					<canvas id="pong-canvas" width="800" height="400"></canvas>
					<div id="pong-start-screen" class="pong-overlay">
						<i class="bi bi-person-workspace fs-1 mb-3 text-danger"></i>
						<h3 class="fw-bold mb-2">Pong : Le Grand Test</h3>
						<p class="text-center px-4 small mb-4">La balle est votre **CV**. Ne laissez pas le recruteur l'ignorer !<br>Bloquez les refus et marquez des points.</p>
						<button class="btn-restart" onclick="startPong()">Démarrer l'Entretien</button>
						<p class="pong-hint">
							<i class="bi bi-mouse2 me-1"></i>
							Utilisez votre souris pour bouger</p>
					</div>
				</div>
			</div>

			<!-- Tetris Game -->
			<div class="tab-pane fade" id="tetris">
				<div class="tetris-container mb-4">
					<canvas id="tetris-canvas" width="240" height="400"></canvas>
					<div class="tetris-info">
						<div class="tetris-stat">
							<h6>Algorithmique</h6>
							<div id="tetris-score">0</div>
						</div>
						<div class="tetris-stat">
							<h6>Lines (Clean Code)</h6>
							<div id="tetris-lines">0</div>
						</div>
						<div class="tetris-stat">
							<h6>Next Module</h6>
							<canvas id="tetris-next-canvas" width="80" height="80"></canvas>
						</div>
						<button class="btn-restart" onclick="startTetris()">Compiler le Code</button>
					</div>
				</div>
				<div class="d-flex justify-content-center">
					<p class="text-muted small">
						<i class="bi bi-keyboard me-2"></i>Flèches : Déplacer | Haut : Tourner | Bas : Accélérer</p>
				</div>
			</div>
		</div>
	</div>
</section>

<div id="badge-notification">
	<div class="d-flex align-items-center gap-3 text-white">
		<i class="bi bi-patch-check-fill fs-1 text-warning"></i>
		<div>
			<h5 class="fw-bold mb-0">Full-Stack Unlocked!</h5>
			<small>Félicitations, vous maîtrisez la stack !</small>
		</div>
	</div>
</div>

<div id="info-panel">
	<div class="d-flex align-items-center gap-4 text-white">
		<div id="info-icon" style="font-size: 3rem;"></div>
		<div>
			<h4 class="fw-bold mb-1" id="info-title">Nom</h4>
			<p class="mb-0 opacity-75" id="info-desc">Description...</p>
		</div>
		<button class="btn-close btn-close-white ms-auto" onclick="closeInfo()"></button>
	</div>
</div>{% endblock %}{% block javascripts %}
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
<!-- MediaPipe Hands -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

<script>
	// --- WEBCAM HAND TRACKING LOGIC ---
let handCamera = null;
let handModel = null;
let isWebcamActive = false;
const virtualCursor = document.getElementById('virtual-cursor');
const webcamContainer = document.getElementById('webcam-container');
const handLoading = document.getElementById('hand-loading');

function onResults(results) {
const canvasCtx = document.getElementById('output_canvas').getContext('2d');
canvasCtx.save();
canvasCtx.clearRect(0, 0, 200, 150);
canvasCtx.drawImage(results.image, 0, 0, 200, 150);

if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
const landmarks = results.multiHandLandmarks[0];

// Draw skeleton on small canvas
drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {
color: '#00FF00',
lineWidth: 2
});
drawLandmarks(canvasCtx, landmarks, {
color: '#FF0000',
lineWidth: 1
});

// Index Finger Tip (Landmark 8) for Cursor
const indexTip = landmarks[8];
const thumbTip = landmarks[4];

// Map coordinates to screen (mirror effect already applied on video, so we just map x)
// Note: landmarks.x is normalized [0, 1]. Inverted because video is mirrored via CSS but coordinates are raw.
// Actually MediaPipe outputs normalized coordinates.
// If user moves hand right (his perspective), it's left on screen if mirrored.
// Let's assume standard mapping: x=0 is left, x=1 is right.

// Smooth Cursor Movement (Lerp)
const targetX = (1 - indexTip.x) * window.innerWidth;
const targetY = indexTip.y * window.innerHeight;

// Simple linear interpolation for smoothness (approximate current position if needed,
// but direct assignment is responsive. Let's keep direct but maybe add a small delay check if jittery.
// For now, direct mapping is fastest.)
const screenX = targetX;
const screenY = targetY;

virtualCursor.style.left = `${screenX}px`;
virtualCursor.style.top = `${screenY}px`;

// Pinch Detection (Click) - Increased threshold for easier activation
const distance = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);

if (distance < 0.08) { // Threshold for pinch (increased from 0.05)
virtualCursor.style.backgroundColor = '#00FF00'; // Green on click
virtualCursor.style.transform = 'translate(-50%, -50%) scale(0.8)';

// Trigger Click on Element
const element = document.elementFromPoint(screenX, screenY);
if (element) {
const card = element.closest('.memory-card');
if (card && ! card.classList.contains('flipped') && ! card.classList.contains('matched')) {
if (! card.hasAttribute('data-clicked')) {
card.click();
card.setAttribute('data-clicked', 'true');
setTimeout(() => card.removeAttribute('data-clicked'), 800);
}
}
}
} else {
virtualCursor.style.backgroundColor = 'rgba(213, 46, 40, 0.7)';
virtualCursor.style.transform = 'translate(-50%, -50%) scale(1)';
}
}
canvasCtx.restore();
}

function toggleWebcam() {
if (isWebcamActive) { // Stop Camera
if (handCamera) 
handCamera.stop();



webcamContainer.style.display = 'none';
virtualCursor.style.display = 'none';
document.getElementById('btn-webcam').innerHTML = '<i class="bi bi-camera-video me-2"></i> Activer Contrôle Main (IA)';
isWebcamActive = false;
} else { // Start Camera
handLoading.style.display = 'block';

const videoElement = document.getElementById('input_video');

if (! handModel) {
handModel = new Hands({
locateFile: (file) => {
return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
}
});

handModel.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});

handModel.onResults(onResults);
}

handCamera = new Camera(videoElement, {
onFrame: async () => {
await handModel.send({image: videoElement});
if (handLoading.style.display === 'block') {
handLoading.style.display = 'none';
webcamContainer.style.display = 'block';
virtualCursor.style.display = 'block';
}
},
width: 640,
height: 480
});

handCamera.start();
document.getElementById('btn-webcam').innerHTML = '<i class="bi bi-stop-circle me-2"></i> Désactiver IA';
isWebcamActive = true;
}
}

// --- MEMORY GAME LOGIC ---
const techData = [
{
name: 'Python',
icon: 'bi-code-slash',
desc: 'Le roi de l\'intelligence artificielle et du scripting rapide.'
},
{
name: 'React',
icon: 'bi-atom',
desc: 'La bibliothèque JS incontournable pour des interfaces ultra-dynamiques.'
},
{
name: 'Symfony',
icon: 'bi-lightning-fill',
desc: 'Framework PHP français d\'excellence pour des projets robustes.'
},
{
name: 'Docker',
icon: 'bi-box-seam',
desc: 'Simplifie le déploiement en encapsulant vos apps dans des conteneurs.'
}, {
name: 'JavaScript',
icon: 'bi-braces',
desc: 'Le langage qui donne vie au web sur tous les écrans.'
}, {
name: 'PHP',
icon: 'bi-filetype-php',
desc: 'Puissant et flexible, il propulse une immense majorité du web.'
}, {
name: 'Git',
icon: 'bi-git',
desc: 'Le système de contrôle de version essentiel pour tout développeur.'
}, {
name: 'SQL',
icon: 'bi-database',
desc: 'Langage universel pour manipuler et interroger vos bases de données.'
}
];

let flippedCards = [];
let moves = 0,
matches = 0,
seconds = 0;
let timerInterval,
canFlip = true,
infoTimeout;

function initMemory() {
const grid = document.getElementById('game-grid');
grid.innerHTML = '';
moves = matches = seconds = 0;
flippedCards = [];
canFlip = true;
document.getElementById('move-count').innerText = moves;
document.getElementById('match-count').innerText = matches;
document.getElementById('timer').innerText = '00:00';
clearInterval(timerInterval);
startTimer();

const data = [
... techData,
... techData
].sort(() => Math.random() - 0.5);
data.forEach((tech) => {
const card = document.createElement('div');
card.className = 'memory-card';
card.innerHTML = `<div class="card-face card-front"></div><div class="card-face card-back"><i class="bi ${
tech.icon
}"></i><span>${
tech.name
}</span></div>`;
card.onclick = () => {
if (! canFlip || card.classList.contains('flipped') || card.classList.contains('matched')) 
return;



card.classList.add('flipped');
flippedCards.push({card, tech});
if (flippedCards.length === 2) {
canFlip = false;
moves++;
document.getElementById('move-count').innerText = moves;
if (flippedCards[0].tech.name === flippedCards[1].tech.name) {
matches++;
document.getElementById('match-count').innerText = matches;
flippedCards.forEach(c => c.card.classList.add('matched'));
showInfo(flippedCards[0].tech);
flippedCards = [];
canFlip = true;
if (matches === 8) 
endGame();



} else {
setTimeout(() => {
flippedCards.forEach(c => c.card.classList.remove('flipped'));
flippedCards = [];
canFlip = true;
}, 1000);
}
}
};
grid.appendChild(card);
});
}

function startTimer() {
timerInterval = setInterval(() => {
seconds++;
const m = Math.floor(seconds / 60).toString().padStart(2, '0');
const s = (seconds % 60).toString().padStart(2, '0');
document.getElementById('timer').innerText = `${m}:${s}`;
}, 1000);
}

function showInfo(tech) {
const p = document.getElementById('info-panel');
document.getElementById('info-icon').innerHTML = `<i class="bi ${
tech.icon
} text-danger"></i>`;
document.getElementById('info-title').innerText = tech.name;
document.getElementById('info-desc').innerText = tech.desc;
p.style.display = 'block';

if (infoTimeout) 
clearTimeout(infoTimeout);

infoTimeout = setTimeout(closeInfo, 3000);
}

function closeInfo() {
document.getElementById('info-panel').style.display = 'none';
}
function resetMemory() {
closeInfo();
initMemory();
}

function endGame() {
clearInterval(timerInterval);
confetti({
particleCount: 150,
spread: 70,
origin: {
y: 0.6
},
colors: ['#d52e28', '#102c59', '#28a745']
});
}

// --- TIC-TAC-TOE LOGIC ---
let tttBoard = Array(9).fill(null);
let tttActive = true;
let currentPlayer = 'X'; // X is HTML (red), O is CSS (blue)
let isSolo = true;

const tttCells = document.querySelectorAll('.ttt-cell');
tttCells.forEach(cell => cell.addEventListener('click', () => handleTTTMove(cell.dataset.index)));

function handleTTTMove(index) {
if (! tttActive || tttBoard[index]) 
return;



makeMove(index, currentPlayer);

if (checkWin(tttBoard, currentPlayer)) {
endTTT(currentPlayer);
} else if (tttBoard.every(c => c)) {
endTTT(null);
} else {
currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
document.getElementById('ttt-turn').innerText = currentPlayer === 'X' ? 'HTML (X)' : 'CSS (O)';

if (isSolo && currentPlayer === 'O') {
setTimeout(aiMove, 500);
}
}
}

function makeMove(index, player) {
tttBoard[index] = player;
const cell = document.querySelector (`.ttt-cell[data-index="${index}"]`);
cell.classList.add('taken', player.toLowerCase());
const skill = player === 'X' ? 'HTML' : 'CSS';
const icon = player === 'X' ? 'bi-filetype-html' : 'bi-filetype-css';
cell.innerHTML = `<div><div class="skill-icon"><i class="bi ${icon}"></i></div>${player}</div>`;
}

function aiMove() {
if (! tttActive) 
return;



const empty = tttBoard.map((v, i) => v === null ? i : null).filter(v => v !== null);
const random = empty[Math.floor(Math.random() * empty.length)];
handleTTTMove(random);
}

function checkWin(board, player) {
const wins = [
[
0, 1, 2
],
[
3, 4, 5
],
[
6, 7, 8
],
[
0, 3, 6
],
[
1, 4, 7
],
[
2, 5, 8
],
[
0, 4, 8
],
[
2, 4, 6
]
];
return wins.some(comb => comb.every(i => board[i] === player));
}

function endTTT(winner) {
tttActive = false;
if (winner) {
confetti({
particleCount: 100,
spread: 50,
origin: {
y: 0.8
}
});
if (winner === 'X') {
document.getElementById('badge-notification').style.display = 'block';
setTimeout(() => document.getElementById('badge-notification').style.display = 'none', 5000);
}
alert(winner === 'X' ? "Full-Stack Unlocked! Vous avez gagné!" : "L'IA a gagné! Réessayez.");
} else {
alert("Match nul !");
}
}

function resetTTT() {
tttBoard = Array(9).fill(null);
tttActive = true;
currentPlayer = 'X';
document.getElementById('ttt-turn').innerText = 'HTML (X)';
tttCells.forEach(c => {
c.className = 'ttt-cell';
c.innerHTML = '';
});
}

function toggleTTTMode() {
isSolo = ! isSolo;
document.getElementById('ttt-mode').innerText = isSolo ? 'Solo vs IA' : '2 Joueurs';
resetTTT();
}

// --- SNAKE GAME LOGIC ---
const canvas = document.getElementById('snake-canvas');
const ctx = canvas.getContext('2d');
const box = 20;
let snake,
food,
d,
gameSpeed,
snakeScore;
let snakeInterval;

const gameIcons = [
{
name: 'Python',
icon: 'bi-filetype-py',
color: '#3776ab'
},
{
name: 'React',
icon: 'bi-atom',
color: '#61dafb'
},
{
name: 'JS',
icon: 'bi-filetype-js',
color: '#f7df1e'
},
{
name: 'PHP',
icon: 'bi-filetype-php',
color: '#777bb4'
}, {
name: 'SQL',
icon: 'bi-database',
color: '#00758f'
}
];

function startSnake() {
document.getElementById('snake-start-screen').style.display = 'none';
snake = [{
x: 9 * box,
y: 10 * box
}];
spawnFood();
d = 'RIGHT';
snakeScore = 0;
gameSpeed = 100;
document.getElementById('snake-score').innerText = snakeScore;
document.getElementById('snake-current-score').innerText = snakeScore;

if (snakeInterval) 
clearInterval(snakeInterval);



snakeInterval = setInterval(drawSnake, gameSpeed);

document.addEventListener('keydown', direction);
}

function spawnFood() {
food = {
x: Math.floor(Math.random() * 19 + 1) * box,
y: Math.floor(Math.random() * 19 + 1) * box,
info: gameIcons[Math.floor(Math.random() * gameIcons.length)]
};
}

function direction(event) {
let key = event.keyCode;
if ([37, 38, 39, 40].includes(key)) {
event.preventDefault(); // Empêche le défilement de la page
}
if (key == 37 && d != 'RIGHT') 
d = 'LEFT';
 else if (key == 38 && d != 'DOWN') 
d = 'UP';
 else if (key == 39 && d != 'LEFT') 
d = 'RIGHT';
 else if (key == 40 && d != 'UP') 
d = 'DOWN';



}

function collision(head, array) {
for (let i = 0; i < array.length; i++) {
if (head.x == array[i].x && head.y == array[i].y) 
return true;



}
return false;
}

function drawSnake() {
ctx.fillStyle = '#0a0a0a';
ctx.fillRect(0, 0, canvas.width, canvas.height);

// Grid
ctx.strokeStyle = '#111';
for (let i = 0; i < canvas.width; i += box) {
ctx.beginPath();
ctx.moveTo(i, 0);
ctx.lineTo(i, canvas.height);
ctx.stroke();
ctx.beginPath();
ctx.moveTo(0, i);
ctx.lineTo(canvas.width, i);
ctx.stroke();
}

for (let i = 0; i < snake.length; i++) {
ctx.fillStyle = (i == 0) ? '#d52e28' : '#fff';
ctx.shadowBlur = (i == 0) ? 10 : 0;
ctx.shadowColor = '#d52e28';
ctx.fillRect(snake[i].x, snake[i].y, box, box);
ctx.strokeStyle = '#000';
ctx.strokeRect(snake[i].x, snake[i].y, box, box);
ctx.shadowBlur = 0;
}

// Draw Food (Logo style)
ctx.fillStyle = food.info.color;
ctx.beginPath();
ctx.arc(food.x + box / 2, food.y + box / 2, box / 2 - 2, 0, Math.PI * 2);
ctx.fill();
ctx.fillStyle = "#fff";
ctx.font = "12px BootstrapIcons";
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillText(food.info.name[0], food.x + box / 2, food.y + box / 2);

let snakeX = snake[0].x;
let snakeY = snake[0].y;

if (d == 'LEFT') 
snakeX -= box;



if (d == 'UP') 
snakeY -= box;



if (d == 'RIGHT') 
snakeX += box;



if (d == 'DOWN') 
snakeY += box;



if (snakeX == food.x && snakeY == food.y) {
snakeScore++;
updatePersLevel(snakeScore);
document.getElementById('snake-score').innerText = snakeScore;
document.getElementById('snake-current-score').innerText = snakeScore;

// Speed up
if (snakeScore % 5 === 0 && gameSpeed > 50) {
gameSpeed -= 5;
clearInterval(snakeInterval);
snakeInterval = setInterval(drawSnake, gameSpeed);
}

spawnFood();
} else {
snake.pop();
}

let newHead = {
x: snakeX,
y: snakeY
};

if (snakeX < 0 || snakeX >= canvas.width || snakeY < 0 || snakeY >= canvas.height || collision(newHead, snake)) {
gameOverSnake();
return;
}

snake.unshift(newHead);
}

function gameOverSnake() {
clearInterval(snakeInterval);
document.getElementById('snake-start-screen').style.display = 'flex';
document.getElementById('snake-start-screen').querySelector('h3').innerText = 'Game Over !';
document.getElementById('snake-start-screen').querySelector('p').innerText = 'Votre persévérance a atteint le score de ' + snakeScore;

if (snakeScore > 10) {
confetti({
particleCount: 50,
spread: 30,
origin: {
y: 0.8
}
});
}
}

function updatePersLevel(score) {
const levelSpan = document.getElementById('snake-pers-level');
if (score > 30) 
levelSpan.innerText = 'Maître';
 else if (score > 20) 
levelSpan.innerText = 'Expert';
 else if (score > 10) 
levelSpan.innerText = 'Déterminé';
 else 
levelSpan.innerText = 'Apprenti';



}

// --- PONG GAME LOGIC ---
const pCanvas = document.getElementById('pong-canvas');
const pCtx = pCanvas.getContext('2d');
let pongRunning = false;

const ball = {
x: pCanvas.width / 2,
y: pCanvas.height / 2,
radius: 10,
speed: 5,
velocityX: 5,
velocityY: 5,
color: "#fff"
};

const user = {
x: 0,
y: pCanvas.height / 2 - 50,
width: 10,
height: 100,
score: 0,
color: "#d52e28"
};

const ai = {
x: pCanvas.width - 10,
y: pCanvas.height / 2 - 50,
width: 10,
height: 100,
score: 0,
color: "#9dbbce"
};

const net = {
x: pCanvas.width / 2 - 1,
y: 0,
width: 2,
height: 10,
color: "rgba(255,255,255,0.1)"
};

function startPong() {
document.getElementById('pong-start-screen').style.display = 'none';
pongRunning = true;
user.score = 0;
ai.score = 0;
updatePongScore();
resetBall();
document.getElementById('pong-status').innerText = 'Entretien en cours';
gamePong();
}

function drawRect(x, y, w, h, color) {
pCtx.fillStyle = color;
pCtx.fillRect(x, y, w, h);
}

function drawNet() {
for (let i = 0; i <= pCanvas.height; i += 15) {
drawRect(net.x, net.y + i, net.width, net.height, net.color);
}
}

function drawBall(x, y, r, color) { // Draw CV icon
pCtx.fillStyle = color;
pCtx.beginPath();
pCtx.arc(x, y, r, 0, Math.PI * 2, false);
pCtx.fill();

pCtx.fillStyle = "#000";
pCtx.font = "bold 8px Arial";
pCtx.textAlign = "center";
pCtx.fillText("CV", x, y + 3);
}

function resetBall() {
ball.x = pCanvas.width / 2;
ball.y = pCanvas.height / 2;
ball.velocityX = - ball.velocityX;
ball.speed = 5;
}

function updatePongScore() {
document.getElementById('player-score').innerText = user.score;
document.getElementById('ai-score').innerText = ai.score;
}

pCanvas.addEventListener("mousemove", (evt) => {
if (! pongRunning) 
return;



let rect = pCanvas.getBoundingClientRect();
let scaleY = pCanvas.height / rect.height;
user.y = (evt.clientY - rect.top) * scaleY - user.height / 2;

// Boundaries
if (user.y < 0) 
user.y = 0;



if (user.y + user.height > pCanvas.height) 
user.y = pCanvas.height - user.height;



});

function collisionPong(b, p) {
p.top = p.y;
p.bottom = p.y + p.height;
p.left = p.x;
p.right = p.x + p.width;

b.top = b.y - b.radius;
b.bottom = b.y + b.radius;
b.left = b.x - b.radius;
b.right = b.x + b.radius;

return b.right > p.left && b.bottom > p.top && b.left < p.right && b.top < p.bottom;
}

function updatePong() {
if (ball.x - ball.radius < 0) {
ai.score ++;
updatePongScore();
resetBall();
} else if (ball.x + ball.radius > pCanvas.width) {
user.score ++;
updatePongScore();
resetBall();
if (user.score % 3 === 0) {
confetti({
particleCount: 30,
spread: 20,
origin: {
x: ball.x / pCanvas.width,
y: ball.y / pCanvas.height
}
});
}
}

ball.x += ball.velocityX;
ball.y += ball.velocityY;

// IA Recruteur (Follow the ball with some delay)
ai.y += (ball.y -(ai.y + ai.height / 2)) * 0.08;

if (ball.y - ball.radius < 0 || ball.y + ball.radius > pCanvas.height) {
ball.velocityY = - ball.velocityY;
}

let player = (ball.x < pCanvas.width / 2) ? user : ai;

if (collisionPong(ball, player)) {
let collidePoint = (ball.y -(player.y + player.height / 2));
collidePoint = collidePoint / (player.height / 2);
let angleRad = (Math.PI / 4) * collidePoint;
let direction = (ball.x < pCanvas.width / 2) ? 1 : -1;
ball.velocityX = direction * ball.speed * Math.cos(angleRad);
ball.velocityY = ball.speed * Math.sin(angleRad);
ball.speed += 0.5;
document.getElementById('pong-speed').innerText = (ball.speed / 5).toFixed(1) + 'x';
}
}

function renderPong() {
drawRect(0, 0, pCanvas.width, pCanvas.height, "#050d1a");
drawNet();
drawRect(user.x, user.y, user.width, user.height, user.color);
drawRect(ai.x, ai.y, ai.width, ai.height, ai.color);
drawBall(ball.x, ball.y, ball.radius, ball.color);
}

function gamePong() {
if (! pongRunning) 
return;



updatePong();
renderPong();
requestAnimationFrame(gamePong);
}

// --- TETRIS GAME LOGIC ---
const tCanvas = document.getElementById('tetris-canvas');
const tCtx = tCanvas.getContext('2d');
const nCanvas = document.getElementById('tetris-next-canvas');
const nCtx = nCanvas.getContext('2d');

const ROW = 20;
const COL = 12;
const SQ = 20;
const VACANT = "black";

const PIECES = [
[
[
[
0, 0, 1
],
[
1, 1, 1
],
[
0, 0, 0
]
],
"#f00",
"Function"
],
[
[
[
1, 1, 0
],
[
0, 1, 1
],
[
0, 0, 0
]
],
"#0f0",
"Loop"
],
[
[
[
0, 1, 1
],
[
1, 1, 0
],
[
0, 0, 0
]
],
"#00f",
"IfElse"
],
[
[
[1, 1, 1, 1]
],
"#ff0",
"Array"
],
[
[
[
1, 1
],
[
1, 1
]
],
"#f0f",
"Object"
],
[
[
[
1, 1, 1
],
[
1, 0, 0
]
],
"#0ff",
"Class"
],
[
[
[
1, 1, 1
],
[
0, 0, 1
]
],
"#ffa500",
"String"
]
];

let board = [];
for (r = 0; r < ROW; r ++) {
board[r] = [];
for (c = 0; c < COL; c ++) {
board[r][c] = VACANT;
}
}

function drawSquare(x, y, color, context = tCtx) {
context.fillStyle = color;
context.fillRect(x * SQ, y * SQ, SQ, SQ);
context.strokeStyle = "#111";
context.strokeRect(x * SQ, y * SQ, SQ, SQ);
}

function drawBoard() {
for (r = 0; r < ROW; r ++) {
for (c = 0; c < COL; c ++) {
drawSquare(c, r, board[r][c]);
}
}
}

class Piece {
constructor(tetromino, color, name) {
this.tetromino = tetromino;
this.color = color;
this.name = name;
this.tetrominoN = 0;
this.activeTetromino = this.tetromino[this.tetrominoN];
this.x = 3;
this.y = -2;
}

fill(color) {
for (r = 0; r < this.activeTetromino.length; r ++) {
for (c = 0; c < this.activeTetromino[r].length; c ++) {
if (this.activeTetromino[r][c]) {
drawSquare(this.x + c, this.y + r, color);
}
}
}
}

draw() {
this.fill(this.color);
}
unDraw() {
this.fill(VACANT);
}

moveDown() {
if (!this.collision(0, 1, this.activeTetromino)) {
this.unDraw();
this.y ++;
this.draw();
} else {
this.lock();
p = nextP;
nextP = randomPiece();
drawNext();
}
}

moveRight() {
if (!this.collision(1, 0, this.activeTetromino)) {
this.unDraw();
this.x ++;
this.draw();
}
}

moveLeft() {
if (!this.collision(-1, 0, this.activeTetromino)) {
this.unDraw();
this.x --;
this.draw();
}
}

rotate() {
let nextPattern = this.tetromino[(this.tetrominoN + 1) % this.tetromino.length];
let kick = 0;
if (this.collision(0, 0, nextPattern)) {
if (this.x > COL / 2) {
kick = -1;
} else {
kick = 1;
}
}
if (!this.collision(kick, 0, nextPattern)) {
this.unDraw();
this.x += kick;
this.tetrominoN = (this.tetrominoN + 1) % this.tetromino.length;
this.activeTetromino = this.tetromino[this.tetrominoN];
this.draw();
}
}

collision(x, y, piece) {
for (r = 0; r < piece.length; r ++) {
for (c = 0; c < piece[r].length; c ++) {
if (!piece[r][c]) {
continue;
}
let newX = this.x + c + x;
let newY = this.y + r + y;
if (newX < 0 || newX >= COL || newY >= ROW) {
return true;
}
if (newY < 0) {
continue;
}
if (board[newY][newX] != VACANT) {
return true;
}
}
}
return false;
}

lock() {
for (r = 0; r < this.activeTetromino.length; r ++) {
for (c = 0; c < this.activeTetromino[r].length; c ++) {
if (!this.activeTetromino[r][c]) {
continue;
}
if (this.y + r < 0) {
alert("Stack Overflow ! Code trop complexe.");
gameOverTetris = true;
break;
}
board[this.y + r][this.x + c] = this.color;
}
}
// remove full rows
for (r = 0; r < ROW; r ++) {
let isRowFull = true;
for (c = 0; c < COL; c ++) {
isRowFull = isRowFull && (board[r][c] != VACANT);
}
if (isRowFull) {
for (y = r; y > 1; y --) {
for (c = 0; c < COL; c ++) {
board[y][c] = board[y - 1][c];
}
}
for (c = 0; c < COL; c ++) {
board[0][c] = VACANT;
}
tetrisScore += 10;
tetrisLines++;
}
}
drawBoard();
document.getElementById('tetris-score').innerText = tetrisScore;
document.getElementById('tetris-lines').innerText = tetrisLines;
}
}

function rotateTetromino(tetromino) {
const N = tetromino.length;
const M = tetromino[0].length;
const rotated = Array.from({
length: M
}, () => Array(N).fill(0));
for (let r = 0; r < N; r++) {
for (let c = 0; c < M; c++) {
rotated[c][N - 1 - r] = tetromino[r][c];
}
}
return rotated;
}

function generateRotations(pattern) {
let rotations = [pattern];
let current = pattern;
for (let i = 0; i < 3; i++) {
current = rotateTetromino(current);
rotations.push(current);
}
return rotations;
}

function randomPiece() {
let r = Math.floor(Math.random() * PIECES.length);
let pattern = PIECES[r][0];
let rotations = generateRotations(pattern);
return new Piece(rotations, PIECES[r][1], PIECES[r][2]);
}

let p = randomPiece();
let nextP = randomPiece();
let tetrisScore = 0;
let tetrisLines = 0;
let gameOverTetris = false;
let dropStart = Date.now();

function drawNext() {
nCtx.fillStyle = "black";
nCtx.fillRect(0, 0, 80, 80);
for (r = 0; r < nextP.activeTetromino.length; r ++) {
for (c = 0; c < nextP.activeTetromino[r].length; c ++) {
if (nextP.activeTetromino[r][c]) {
nCtx.fillStyle = nextP.color;
nCtx.fillRect((c + 1) * SQ / 1.5, (r + 1) * SQ / 1.5, SQ / 1.5, SQ / 1.5);
nCtx.strokeStyle = "#111";
nCtx.strokeRect((c + 1) * SQ / 1.5, (r + 1) * SQ / 1.5, SQ / 1.5, SQ / 1.5);
}
}
}
}

function startTetris() {
board = [];
for (r = 0; r < ROW; r ++) {
board[r] = [];
for (c = 0; c < COL; c ++) {
board[r][c] = VACANT;
}
}
tetrisScore = 0;
tetrisLines = 0;
gameOverTetris = false;
document.getElementById('tetris-score').innerText = 0;
document.getElementById('tetris-lines').innerText = 0;
p = randomPiece();
nextP = randomPiece();
drawBoard();
drawNext();
drop();
}

function drop() {
let now = Date.now();
let delta = now - dropStart;
if (delta > 1000) {
p.moveDown();
dropStart = Date.now();
}
if (! gameOverTetris) {
requestAnimationFrame(drop);
}
}

document.addEventListener("keydown", (event) => {
const key = event.keyCode;
if ([37, 38, 39, 40].includes(key)) {
event.preventDefault();
}
if (key == 37) 
p.moveLeft();
 else if (key == 38) 
p.rotate();
 else if (key == 39) 
p.moveRight();
 else if (key == 40) 
p.moveDown();



});

document.addEventListener('DOMContentLoaded', () => {
initMemory();
});
</script>{% endblock %}
